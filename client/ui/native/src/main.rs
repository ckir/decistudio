//! # DeciStudio Native Client
//! 
//! Desktop entry point. This version uses an event-loop invocation strategy
//! to maximize the window as soon as the platform backend is ready,
//! minimizing the delay seen with standard timers.

use slint::ComponentHandle;

// Include the modules generated by the slint-build crate
slint::include_modules!();

/// The entry point for the native desktop application.
/// 
/// // This function initializes the UI and schedules a maximize command
/// // through the event loop to ensure proper timing with the OS.
fn main() -> Result<(), slint::PlatformError> {
    // Instantiate the UI component
    let ui = AppWindow::new()?;

    // Use a weak handle to avoid capture-cycles in the closure
    let ui_weak = ui.as_weak();

    // Instead of a long 3000ms timer, we "invoke" from the event loop.
    // // This queues the command to run immediately after the window is shown.
    slint::invoke_from_event_loop(move || {
        if let Some(ui) = ui_weak.upgrade() {
            // Command the window manager to maximize
            ui.window().set_maximized(true);
            
            // Set the initial workspace state
            // // This clears pre-existing text for the clipping logic
            ui.set_editor_content("// DeciStudio Native\n// Workspace maximized via event-loop synchronization.".into());
        }
    }).expect("Failed to queue maximization command");

    // Start the Slint event loop
    // // The window will appear and then immediately maximize
    ui.run()
}